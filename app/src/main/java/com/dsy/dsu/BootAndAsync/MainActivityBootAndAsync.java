package com.dsy.dsu.BootAndAsync;import android.annotation.SuppressLint;import android.app.Activity;import android.content.ComponentName;import android.content.ContentResolver;import android.content.ContentValues;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.content.SharedPreferences;import android.content.pm.ActivityInfo;import android.content.pm.PackageManager;import android.database.Cursor;import android.graphics.Color;import android.graphics.PorterDuff;import android.graphics.drawable.Drawable;import android.net.Uri;import android.os.Build;import android.os.Bundle;import android.os.Handler;import android.os.IBinder;import android.os.Looper;import android.os.Message;import android.util.Log;import android.view.Gravity;import android.view.MenuItem;import android.view.View;import android.view.WindowManager;import android.widget.ProgressBar;import android.widget.Toast;import androidx.annotation.NonNull;import androidx.annotation.RequiresApi;import androidx.appcompat.app.AppCompatActivity;import androidx.drawerlayout.widget.DrawerLayout;import com.dsy.dsu.AllTestsBusinessLogic.AllTestsBusinessLogic;import com.dsy.dsu.BroadcastRecievers.ClassRegistraAsyncBroadcast;import com.dsy.dsu.BusinessLogicAll.Class_Connections_Server;import com.dsy.dsu.BusinessLogicAll.CreateFolderBinatySave.ClassCreateFolderCommitPays1C;import com.dsy.dsu.Errors.Class_Generation_Errors;import com.dsy.dsu.BusinessLogicAll.CreateFolderBinatySave.ClassCreateFolderBinatyMatrilal;import com.dsy.dsu.BusinessLogicAll.DATE.SubClassCursorLoader;import com.dsy.dsu.BusinessLogicAll.Errors.ClassCreateFileForError;import com.dsy.dsu.BusinessLogicAll.Permissions.ClassPermissions;import com.dsy.dsu.CnangeServers.PUBLIC_CONTENT;import com.dsy.dsu.Errors.MainActivity_Errors;import com.dsy.dsu.Passwords.MainActivityPasswords;import com.dsy.dsu.Services.ServiceUpdatePoОбновлениеПО;import com.dsy.dsu.Services.Service_For_Remote_Async_Binary;import com.dsy.dsu.Dashboard.MainActivity_Dashboard;import com.dsy.dsu.R;import com.google.android.material.navigation.NavigationView;import java.net.HttpURLConnection;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.Locale;import java.util.TimeZone;import java.util.concurrent.TimeUnit;import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;import io.reactivex.rxjava3.core.Completable;import io.reactivex.rxjava3.core.CompletableObserver;import io.reactivex.rxjava3.core.Flowable;import io.reactivex.rxjava3.core.Observable;import io.reactivex.rxjava3.disposables.Disposable;import io.reactivex.rxjava3.functions.Action;import io.reactivex.rxjava3.functions.BiFunction;import io.reactivex.rxjava3.functions.Consumer;import io.reactivex.rxjava3.schedulers.Schedulers;import io.reactivex.rxjava3.subjects.PublishSubject;import io.reactivex.rxjava3.subjects.Subject;public class MainActivityBootAndAsync extends AppCompatActivity {    private Date ДатаДляИзмененияВерсииДанныхНаАндройде;    private ProgressBar progressbarbootandasync;    private Integer ПолученныйПубличныйID = 0;    private Activity activity;    private String РежимЗапускаСинхронизации = new String();    private PUBLIC_CONTENT Class_Engine_SQLГдеНаходитьсяМенеджерПотоков = null;    private DrawerLayout drawerLayoutAsync;    private NavigationView navigationViewAsyncApp;    private SharedPreferences preferences;    private Handler handlerAsync;    private Handler handlerUpdatePO;    public static final int ALL_PERSSION_CODE=1;    public static final int CAMERA_PERSSION_CODE=2;    private LogicBinessMainActivity_From_Face_Start logicBinessMainActivity_from_face_start;    private BusinessLogicActivityBootAndAsync businessLogicActivityBootAndAsync;    private boolean СтатусРаботыСервера = false;    private boolean ФлагБылиИлиНЕбылПоворотЭкрана = false;    private Service_For_Remote_Async_Binary.LocalBinderAsync localBinderAsync;//TODO нова\    private ServiceUpdatePoОбновлениеПО.localBinderОбновлениеПО localBinderОбновлениеПО;//TODO нова    private  Subject<Service_For_Remote_Async_Binary.LocalBinderAsync> AsyncPublish;    private  Subject<ServiceUpdatePoОбновлениеПО.localBinderОбновлениеПО> UpdatePublish;    private  ServiceConnection connectionОбновлениеПО;    private ServiceConnection connectionAsync;    private Integer ФиналПолучаемРазницуМеждуДатами = 0;    private String success_users;    private String success_login;    private String date_update;    private  String КлючДляFirebaseNotification = "2a1819db-60c8-4ca3-a752-1b6cd9cadfa1";    @SuppressLint("NewApi")    @RequiresApi(api = Build.VERSION_CODES.Q)    @Override    protected void onCreate(Bundle savedInstanceState) {        try {            super.onCreate(savedInstanceState);            setContentView(R.layout.activity_main_bootandasync_prograssbar);            getSupportActionBar().hide(); ///скрывать тул бар            getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);            setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LOCKED);            setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LOCKED);            setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);            // TODO: 07.10.2023  create file for ERROR            ClassCreateFileForError classCreateFileForError=new ClassCreateFileForError();            classCreateFileForError.metodCreateFileForError(this);            // TODO: 14.08.2023 вызов кода ПОльзовательский            preferences = getSharedPreferences("sharedPreferencesХранилище", Context.MODE_MULTI_PROCESS);            РежимЗапускаСинхронизации = preferences.getString("РежимЗапускаСинхронизации","");            progressbarbootandasync = (ProgressBar) findViewById(R.id.progressbarbootandasync); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА/            Drawable progressDrawable = progressbarbootandasync.getProgressDrawable().mutate();            progressDrawable.setColorFilter(Color.parseColor("#00574B"), android.graphics.PorterDuff.Mode.SRC_IN);            progressbarbootandasync.setProgressDrawable(progressDrawable);            drawerLayoutAsync = (DrawerLayout) findViewById(R.id.drawerLayout_async_prograsser); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            drawerLayoutAsync.setBackgroundColor(Color.WHITE);         //TODO устанвливает цвета            drawerLayoutAsync.setDrawingCacheBackgroundColor(Color.RED);//todo            navigationViewAsyncApp    = (NavigationView) findViewById(R.id.navigator_asyncapp); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            activity = this;            // TODO: 29.09.2023 создаем  Init            businessLogicActivityBootAndAsync = new BusinessLogicActivityBootAndAsync();            logicBinessMainActivity_from_face_start = new LogicBinessMainActivity_From_Face_Start();            businessLogicActivityBootAndAsync.МетодИнициализацияОбновленеиПО();            // TODO: 04.10.2023 разрешения для всего            // TODO: 04.10.2023 разрешения для всего            new ClassPermissions(this,ALL_PERSSION_CODE,CAMERA_PERSSION_CODE);            businessLogicActivityBootAndAsync.МетодИнициализацияMessager();            businessLogicActivityBootAndAsync.МетодДляСлушательБоковойПанелиAsyncApp();            // TODO: 02.10.2023 публикации            ClassBindServicePublish classBindServiceAsyncPublish=new ClassBindServicePublish();            classBindServiceAsyncPublish.metodBindServiceAsyncPublish();            // TODO: 14.08.2023 методЗапукска Синхрониазйиии            businessLogicActivityBootAndAsync.МетодБиндингаRemoteAsync();            businessLogicActivityBootAndAsync.МетодБиндингаОбновлениеПО();            // TODO: 12.12.2023  регистируем бродкасресивер            //new Registraziyreciver().staringregistraziyreciver(activity);            Log.d(this.getClass().getName(), "\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() +                    " ФлагБылиИлиНЕбылПоворотЭкрана "                    + ФлагБылиИлиНЕбылПоворотЭкрана);            //TODOntcn код        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    // TODO: 17.08.2023  запуск обновленея ПО и синхрониазции    protected void onStop() {        super.onStop();        try {            Log.d(this.getClass().getName(), "\n" + " class " +                    Thread.currentThread().getStackTrace()[2].getClassName()                    + "\n" +                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    @Override    protected void onDestroy() {        super.onDestroy();        try {            // TODO: 03.10.2023  clear service            logicBinessMainActivity_from_face_start.metodExitBindingeService();            Log.d(this.getClass().getName(), "\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    @Override    protected void onRestart() {        super.onRestart();        try {            Log.d(getApplicationContext().getClass().getName(), "\n"                    + " время: " + new Date() + "\n+" +                    " Класс в процессе... " + this.getClass().getName() + "\n" +                    " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName()                    + "   starting... onRestart" + " starting... onRestart");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    @Override    protected void onStart() {        super.onStart();//////TODO ловим поворот экрана  ДЛЯ СИНХРОНИЗАЦИИ        try {            Log.d(getApplicationContext().getClass().getName(), "\n"                    + " время: " + new Date() + "\n+" +                    " Класс в процессе... " + this.getClass().getName() + "\n" +                    " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    @Override    protected void onResume() {        super.onResume();        try {        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(),                    Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    // TODO: 26.10.2022 сохраняет данные    protected void onSaveInstanceState(Bundle outState) {        try {            Log.i(this.getClass().getName(), "onSaveInstanceState ");            outState.putInt("progressBar4Cycle", progressbarbootandasync.getProgress());            outState.putInt("progressBar4CycleMAx", progressbarbootandasync.getMax());            // TODO: 23.08.203 статуст поворта экрана            outState.putBoolean("asyncTaskLoaderAsync.isStarted()", ФлагБылиИлиНЕбылПоворотЭкрана);            Log.d(getApplicationContext().getClass().getName(), "\n"                    + " время: " + new Date() + "\n+" +                    " Класс в процессе... " + this.getClass().getName() + "\n" +                    " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                    "  ФлагБылиИлиНЕбылПоворотЭкрана " + ФлагБылиИлиНЕбылПоворотЭкрана);            super.onSaveInstanceState(outState);        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    // TODO: 26.10.2022 воставливает данные    protected void onRestoreInstanceState(Bundle savedInstanceState) {        super.onRestoreInstanceState(savedInstanceState);        try {            // businessLogicActivityBootAndAsync.   МетодСитемныйНастройкиЭкран();            // TODO: 25.10.2022 востанавливаем данных после поворота экрана            businessLogicActivityBootAndAsync.МетодВостановлениеЭкранаПослеПоворота(savedInstanceState);            Log.d(getApplicationContext().getClass().getName(), "\n"                    + " время: " + new Date() + "\n+" +                    " Класс в процессе... " + this.getClass().getName() + "\n" +                    " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" + " onRestoreInstanceState");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    @Override    public void onBackPressed() {        //thats it    }    // TODO: 14.08.2023 НАЧИАЕМ БИЗНЕС ЛОГИКУ Активти BootAndAsync    // TODO: 14.08.2023 НАЧИАЕМ БИЗНЕС ЛОГИКУ Активти BootAndAsync    // TODO: 14.08.2023 НАЧИАЕМ БИЗНЕС ЛОГИКУ Активти BootAndAsync    // TODO: 14.08.2023 НАЧИАЕМ БИЗНЕС ЛОГИКУ Активти BootAndAsync   // TODO: 14.08.2023 НАЧИАЕМ БИЗНЕС ЛОГИКУ Активти BootAndAsync   // TODO: 14.08.2023 НАЧИАЕМ БИЗНЕС ЛОГИКУ Активти BootAndAsync    class BusinessLogicActivityBootAndAsync {        private void МетодСитемныйНастройкиЭкран() {            try {                getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD                        | WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON                        | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);                //////todo настрока экрана                getWindow().getDecorView().setSystemUiVisibility(                        View.SYSTEM_UI_FLAG_LAYOUT_STABLE                                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION                                | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN                                | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION                                | View.SYSTEM_UI_FLAG_FULLSCREEN                                | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);                getSupportActionBar().setHomeButtonEnabled(false);                getSupportActionBar().setDisplayHomeAsUpEnabled(false);                getSupportActionBar().setHomeAsUpIndicator(null);                getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);                ((Activity) activity).setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LOCKED);                ((Activity) activity).setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LOCKED);                ((Activity) activity).setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);                // TODO: 25.03.2023                Log.d(this.getClass().getName(), "\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                        " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                        " line " + Thread.currentThread().getStackTrace()[2].getLineNumber());            } catch (Exception e) {                e.printStackTrace();                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }        @RequiresApi(api = Build.VERSION_CODES.Q)        private void МетодБиндингаRemoteAsync() {            try {                // TODO: 28.04.2023  запускаем Гланвную Синхрониазцию                if (ФлагБылиИлиНЕбылПоворотЭкрана == false) {                    //  Intent intentОбноразоваяСинхронизациия = new Intent(getApplicationContext(), Service_For_Remote_Async.class);                    Intent intentAsync = new Intent(getApplicationContext(), Service_For_Remote_Async_Binary.class);                    intentAsync.setAction("com.StartingAsyncMainBackgroud");                    connectionAsync = new ServiceConnection() {                        @Override                        public void onServiceConnected(ComponentName name, IBinder service) {                            try {                                if (service.isBinderAlive()) {                                    // TODO: 29.09.2023                                    localBinderAsync = (Service_For_Remote_Async_Binary.LocalBinderAsync) service;                                    // notify the Observable that the value just change                                    AsyncPublish.onNext(localBinderAsync);                                    // TODO: 25.03.2023                                    Log.d(this.getClass().getName(), "\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                                            " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                                            " line " + Thread.currentThread().getStackTrace()[2].getLineNumber());                                }                            } catch (Exception e) {                                e.printStackTrace();                                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                                        Thread.currentThread().getStackTrace()[2].getLineNumber());                            }                        }                        @Override                        public void onServiceDisconnected(ComponentName name) {                            localBinderAsync = null;                            Log.d(getApplicationContext().getClass().getName().toString(), "\n"                                    + "onServiceConnected  одноразовая  messengerActivity  ");                        }                        @Override                        public void onBindingDied(ComponentName name) {                            ServiceConnection.super.onBindingDied(name);                        }                        @Override                        public void onNullBinding(ComponentName name) {                            ServiceConnection.super.onNullBinding(name);                        }                    };                    Boolean asBoolenCbyСинхронная = bindService(intentAsync,                            connectionAsync, Context.BIND_AUTO_CREATE);                }                // TODO: 28.04.2023                Log.d(this.getClass().getName(), "\n" + " class " +                        Thread.currentThread().getStackTrace()[2].getClassName()                        + "\n" +                        " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                        " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n"  );            } catch (Exception e) {                e.printStackTrace();                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());                Log.d(this.getClass().getName(), "  Полусаем Ошибку e.toString() " + e.toString());            }        }        private void методЗапускаОбновлениеПо(@NonNull Boolean ФлагПОказыватьИлиНЕт) {            try {                localBinderОбновлениеПО.getService().МетодГлавныйОбновленияПО(ФлагПОказыватьИлиНЕт, activity, handlerUpdatePO);                Log.i(this.getClass().getName(), " Атоманически установкаОбновление ПО " +                        Thread.currentThread().getStackTrace()[2].getMethodName() + " время " + new Date().toLocaleString());                Log.i(this.getClass().getName(), "R.id.item_async_updatepo  "                        + Thread.currentThread().getStackTrace()[2].getMethodName() + " время " + new Date().toLocaleString());            } catch (Exception e) {                e.printStackTrace();                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }        private void МетодВостановлениеЭкранаПослеПоворота(@NonNull Bundle savedInstanceState) {            try {                if (progressbarbootandasync.isAttachedToWindow()) {                    progressbarbootandasync.setProgress(savedInstanceState.getInt("progressBar4Cycle", progressbarbootandasync.getProgress()));                    progressbarbootandasync.setMax(savedInstanceState.getInt("progressBar4CycleMAx", progressbarbootandasync.getMax()));                    // TODO: 23.08.2023  Востаноавливем статус поврот экрана                    ФлагБылиИлиНЕбылПоворотЭкрана = savedInstanceState.getBoolean("asyncTaskLoaderAsync.isStarted()");                    progressbarbootandasync.requestLayout();                    progressbarbootandasync.refreshDrawableState();                    drawerLayoutAsync.refreshDrawableState();                    Log.d(getApplicationContext().getClass().getName(), "\n"                            + " время: " + new Date() + "\n+" +                            " Класс в процессе... " + this.getClass().getName() + "\n" +                            " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName()                            + "   savedInstanceState " + savedInstanceState + " ФлагБылиИлиНЕбылПоворотЭкрана " + ФлагБылиИлиНЕбылПоворотЭкрана);                }            } catch (Exception e) {                e.printStackTrace();                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }        // TODO: 02.09.2021  метод Визуализация        private void МетодИнициализацияMessager() {            try {                handlerAsync = new Handler(Looper.getMainLooper()) {                    @Override                    public void handleMessage(@NonNull Message msg) {                        super.handleMessage(msg);                    }                    @Override                    public void dispatchMessage(@NonNull Message msg) {                        super.dispatchMessage(msg);                        try {                            Bundle bundleCallsBackAsynsService = msg.getData();                            switch (msg.what) {                                case 2:// процеессе                                    МетодВизуализацииСинхронизации(bundleCallsBackAsynsService);                                    break;                            }                            progressbarbootandasync.requestLayout();                            progressbarbootandasync.refreshDrawableState();                            Log.d(this.getClass().getName(), "\n" + " class " +                                    Thread.currentThread().getStackTrace()[2].getClassName()                                    + "\n" +                                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n"                                    + " msg.what " + msg.what + "bundleCallsBackAsynsService " + bundleCallsBackAsynsService);                        } catch (Exception e) {                            e.printStackTrace();                            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                    + Thread.currentThread().getStackTrace()[2].getLineNumber());                            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                                    Thread.currentThread().getStackTrace()[2].getLineNumber());                        }                    }                };                Log.i(getApplicationContext().getClass().getName(), " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                        " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                        " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n");            } catch (Exception e) {                e.printStackTrace();                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                        this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }// TODO: 04.10.2023private void МетодДляСлушательБоковойПанелиAsyncApp() {    // TODO: 06.04.2022    try {        drawerLayoutAsync.addDrawerListener(new DrawerLayout.SimpleDrawerListener() {            @Override            public void onDrawerOpened(View drawerView) {                Drawable drawable = getResources().getDrawable(R.mipmap.icon_dsu1_for_asyncapp_close_naviga);///                navigationViewAsyncApp.setVisibility(View.VISIBLE);                super.onDrawerOpened(drawerView);            }            @Override            public void onDrawerClosed(View drawerView) {                Drawable drawable = getResources().getDrawable(R.drawable.icon_dsu1_async_asynprograssbar);///                navigationViewAsyncApp.setVisibility(View.GONE);                super.onDrawerClosed(drawerView);            }        });        navigationViewAsyncApp.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() {            @Override            public boolean onNavigationItemSelected(@NonNull MenuItem item) {                switch (item.getItemId()) {                    // TODO: 06.04.2022 Запускаем ОШибки                    case R.id.one:                        item.setChecked(true);                        Log.w(getPackageName().getClass().getName(), "item.getItemId() Посмотреть ошибки   " + item.getItemId() + "\n");//////////                        try {                            Intent Интент_Меню = new Intent(activity, MainActivity_Errors.class);                            Интент_Меню.setAction("com.CallBackBootAndAsync");                            Интент_Меню.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);//////FLAG_ACTIVITY_SINGLE_TOP                            startActivity(Интент_Меню);                            Log.i(this.getClass().getName(),  "R.id.one "+Thread.currentThread().getStackTrace()[2].getMethodName()+                                    " время " +new Date().toLocaleString() );                        } catch (Exception e) {                            e.printStackTrace();                            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :"                                    + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                    + Thread.currentThread().getStackTrace()[2].getLineNumber());                            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                                    Thread.currentThread().getStackTrace()[2].getLineNumber());                        }                        break;                    // TODO: 06.04.2022 ЗапускаемОбновление ПО                    case R.id.item_async_updatepo:                        item.setChecked(true);                        try {// TODO: 10.07.2023  запуск обновление ПО                            методЗапускаОбновлениеПо(false);                            Log.i(this.getClass().getName(),  " Атоманически установкаОбновление ПО "+ Thread.currentThread().getStackTrace()[2].getMethodName()+ " время " +new Date().toLocaleString() );                            Log.w(getPackageName().getClass().getName(), "item.getItemId() Посмотреть ошибки   " + item.getItemId() + "\n");//////////                            Log.i(this.getClass().getName(),  "R.id.item_async_updatepo  "+Thread.currentThread().getStackTrace()[2].getMethodName()+ " время " +new Date().toLocaleString() );                        } catch (Exception e) {                            e.printStackTrace();                            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                    + Thread.currentThread().getStackTrace()[2].getLineNumber());                            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                                    Thread.currentThread().getStackTrace()[2].getLineNumber());                        }                        break;                }                if (drawerLayoutAsync.isDrawerOpen(Gravity.LEFT)) {                    drawerLayoutAsync.closeDrawer(Gravity.LEFT);                }                return true;            }        });    } catch (Exception e) {        e.printStackTrace();        Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                + Thread.currentThread().getStackTrace()[2].getLineNumber());        new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                Thread.currentThread().getStackTrace()[2].getLineNumber());    }    // TODO: 04.04.2022}        // TODO: 02.09.2021  метод Визуализация        private void МетодИнициализацияОбновленеиПО() {            try {                handlerUpdatePO = new Handler(Looper.getMainLooper()) {                    @Override                    public void handleMessage(@NonNull Message msg) {                        super.handleMessage(msg);                    }                    @Override                    public void dispatchMessage(@NonNull Message msg) {                        super.dispatchMessage(msg);                        try {                            Bundle bundleCallsBackAsynsService = msg.getData();                            if (msg.what==40){                                Integer ЛокальнаяВерсияПОСравнение = msg.arg1;                                Toast toast = Toast.makeText(getApplicationContext(), "Последняя версия ПО !!! " +"("+ЛокальнаяВерсияПОСравнение.toString()+")", Toast.LENGTH_LONG);                                toast.setGravity(Gravity.BOTTOM |Gravity.CENTER_HORIZONTAL, 50, 0);                                toast.show();                            }                            Log.d(this.getClass().getName(), "\n" + " class " +                                    Thread.currentThread().getStackTrace()[2].getClassName()                                    + "\n" +                                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n"                                    + " msg.what " + msg.what + "bundleCallsBackAsynsService " + bundleCallsBackAsynsService);                        } catch (Exception e) {                            e.printStackTrace();                            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                    + Thread.currentThread().getStackTrace()[2].getLineNumber());                            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                                    Thread.currentThread().getStackTrace()[2].getLineNumber());                        }                    }                };                Log.i(getApplicationContext().getClass().getName(), " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                        " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                        " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n");            } catch (Exception e) {                e.printStackTrace();                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                        this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }        private void МетодВизуализацииСинхронизации(@NonNull Bundle bundleCallsBackAsynsService) {            try {                if (progressbarbootandasync.isAttachedToWindow()) {                    Integer ПроцентыNew = bundleCallsBackAsynsService.getInt("Проценны", 0);                    String ИмяТаблица = bundleCallsBackAsynsService.getString("имятаблицы", "");                    Integer MaxКоличествоСТрочеек = bundleCallsBackAsynsService.getInt("maxtables", 0);                    Integer CurrentPotionСТрочеек = bundleCallsBackAsynsService.getInt("currentposition", 0);                    if (CurrentPotionСТрочеек > 0) {                        progressbarbootandasync.setIndeterminate(false);                    }                    progressbarbootandasync.setMax(MaxКоличествоСТрочеек);                    CurrentPotionСТрочеек = CurrentPotionСТрочеек + 1;                    if (CurrentPotionСТрочеек >= progressbarbootandasync.getProgress()) {                        progressbarbootandasync.setProgress(CurrentPotionСТрочеек, true);                        progressbarbootandasync.setProgressTintMode(PorterDuff.Mode.DARKEN);                        // TODO: 14.08.2023                        Integer secondaryProgres = CurrentPotionСТрочеек;                        secondaryProgres++;                        secondaryProgres++;                        progressbarbootandasync.setSecondaryProgress(secondaryProgres);                        progressbarbootandasync.setSecondaryProgressTintMode(PorterDuff.Mode.DARKEN);                    }                    Log.d(this.getClass().getName(), "\n" + " class " +                            Thread.currentThread().getStackTrace()[2].getClassName()                            + "\n" +                            " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                            " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n"                            + " progressbarbootandasync" + progressbarbootandasync.getProgress());                }            } catch (Exception e) {                e.printStackTrace();                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                        this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }        private void МетодБиндингаОбновлениеПО() {            try {                 connectionОбновлениеПО = new ServiceConnection() {                    @Override                    public void onServiceConnected(ComponentName name, IBinder service) {                        try {                            if (service.isBinderAlive()) {                                // TODO: 28.07.2023  Update                                localBinderОбновлениеПО = (ServiceUpdatePoОбновлениеПО.localBinderОбновлениеПО) service;                                // notify the Observable that the value just change                                UpdatePublish.onNext(localBinderОбновлениеПО);                            }                            Log.d(getApplicationContext().getClass().getName(), "\n"                                    + " время: " + new Date() + "\n+" +                                    " Класс в процессе... " + this.getClass().getName() + "\n" +                                    " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n"                                    + "localBinderОбновлениеПО " + localBinderОбновлениеПО);                        } catch (Exception e) {                            e.printStackTrace();                            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                                    " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                                    this.getClass().getName(),                                    Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());                        }                    }                    @Override                    public void onServiceDisconnected(ComponentName name) {                        try {                            localBinderОбновлениеПО = null;                            Log.i(getApplicationContext().getClass().getName(), "    onServiceDisconnected  binder.isBinderAlive()");                        } catch (Exception e) {                            e.printStackTrace();                            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                                    " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                                    this.getClass().getName(),                                    Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());                        }                    }                };                Intent intentЗапускСлужбыОбновлениеПО = new Intent(getApplicationContext(), ServiceUpdatePoОбновлениеПО.class);                intentЗапускСлужбыОбновлениеПО.setAction("com.ServiceUpdatePoОбновлениеПО");                Boolean asBoolenОбновлениеПО = bindService(intentЗапускСлужбыОбновлениеПО, connectionОбновлениеПО, Context.BIND_AUTO_CREATE);                // TODO: 28.04.2023                Log.d(this.getClass().getName(), "\n" + " class " +                        Thread.currentThread().getStackTrace()[2].getClassName()                        + "\n" +                        " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                        " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n" + " asBoolenОбновлениеПО " + asBoolenОбновлениеПО);            } catch (Exception e) {                e.printStackTrace();                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());                Log.d(this.getClass().getName(), "  Полусаем Ошибку e.toString() " + e.toString());            }        }        // TODO: 29.09.2023  метод зарцска синхронизации ВИЗУАЛЬНОЙ                //TODO END  BusinessLogicActivityBootAndAsync //TODO END  BusinessLogicActivityBootAndAsync //TODO END  BusinessLogicActivityBootAndAsync //TODO END  BusinessLogicActivityBootAndAsync    }//TODO END  BusinessLogicActivityBootAndAsync //TODO END  BusinessLogicActivityBootAndAsync //TODO END  BusinessLogicActivityBootAndAsync    // TODO: 14.08.2023  НАЧАЛО БИЗНЕС ЛОГИКИ    LogicBinessMainActivity_From_Face_Start // TODO: 14.08.2023  НАЧАЛО БИЗНЕС ЛОГИКИ    LogicBinessMainActivity_From_Face_Start// TODO: 14.08.2023  НАЧАЛО БИЗНЕС ЛОГИКИ    LogicBinessMainActivity_From_Face_Start // TODO: 14.08.2023  НАЧАЛО БИЗНЕС ЛОГИКИ    LogicBinessMainActivity_From_Face_Start    public class LogicBinessMainActivity_From_Face_Start {        //TODO метод пользовательской дополнительной настройки автозапуса        private void МетодДополнительнойНастрокиАвтоЗапуска() {            try {                final Intent[] AUTO_START_INTENTS = {                        new Intent().setComponent(new ComponentName("com.samsung.android.lool",                                "com.samsung.android.sm.ui.battery.BatteryActivity")),                        new Intent("miui.intent.action.OP_AUTO_START").addCategory(Intent.CATEGORY_DEFAULT),                        new Intent().setComponent(new ComponentName("com.miui.securitycenter", "com.miui.permcenter.autostart.AutoStartManagementActivity")),                        new Intent().setComponent(new ComponentName("com.letv.android.letvsafe", "com.letv.android.letvsafe.AutobootManageActivity")),                        new Intent().setComponent(new ComponentName("com.huawei.systemmanager", "com.huawei.systemmanager.optimize.process.ProtectActivity")),                        new Intent().setComponent(new ComponentName("com.coloros.safecenter", "com.coloros.safecenter.permission.startup.StartupAppListActivity")),                        new Intent().setComponent(new ComponentName("com.coloros.safecenter", "com.coloros.safecenter.startupapp.StartupAppListActivity")),                        new Intent().setComponent(new ComponentName("com.oppo.safe", "com.oppo.safe.permission.startup.StartupAppListActivity")),                        new Intent().setComponent(new ComponentName("com.iqoo.secure", "com.iqoo.secure.ui.phoneoptimize.AddWhiteListActivity")),                        new Intent().setComponent(new ComponentName("com.iqoo.secure", "com.iqoo.secure.ui.phoneoptimize.BgStartUpManager")),                        new Intent().setComponent(new ComponentName("com.vivo.permissionmanager", "com.vivo.permissionmanager.activity.BgStartUpManagerActivity")),                        new Intent().setComponent(new ComponentName("com.asus.mobilemanager", "com.asus.mobilemanager.entry.FunctionActivity")).setData(                                Uri.parse("mobilemanager://function/entry/AutoStart"))                };                for (Intent intent : AUTO_START_INTENTS) {                    if (getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY) != null) {                        startActivity(intent);                        // break;                    }                }            } catch (Exception e) {                e.printStackTrace();                ///метод запись ошибок в таблицу                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                        " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                // TODO: 01.09.2021 метод вызова                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }// TODO: 24.02.2022        /////// МЕТОД КОГДА ЗАХОДИЛ ПОСЛЬДНИЙ РАЗ ПОЛЬЗОВАТЛЬ        @SuppressLint("Range")        private void МетодОпределениеКогдаПоследнийРазЗаходилПользователь() {            Cursor Курсор_7ДнейЗаходаПользователя = null;            try {                Uri uri = Uri.parse("content://com.dsy.dsu.providerdatabasecurrentoperations/" + "successlogin" + "");                ContentResolver contentResolver= getContentResolver();               Курсор_7ДнейЗаходаПользователя =      contentResolver.query(uri,new String[]{},                        new String(" SELECT *  FROM    successlogin   ORDER BY id  LIMIT   1  "),                        new String[]{},null);///   "  //// SELECT * FROM  viewtabel WHERE year_tabels=?  AND month_tabels=?  AND cfo=?  AND status_send!=?                Log.d(this.getClass().getName(), "  Курсор_7ДнейЗаходаПользователя " +  Курсор_7ДнейЗаходаПользователя);                if (Курсор_7ДнейЗаходаПользователя.getCount() > 0) {/////ПРОВЕРЯЕМ ЕСЛИ ПО ДАННОМУ ID UUID ЗАПОЛНЕ ЛИ ОН                    Курсор_7ДнейЗаходаПользователя.moveToFirst();                    success_users =                            Курсор_7ДнейЗаходаПользователя.getString(Курсор_7ДнейЗаходаПользователя.getColumnIndex("success_users")).trim();                    success_login =                            Курсор_7ДнейЗаходаПользователя.getString(Курсор_7ДнейЗаходаПользователя.getColumnIndex("success_login")).trim();                    date_update =                            Курсор_7ДнейЗаходаПользователя.getString(Курсор_7ДнейЗаходаПользователя.getColumnIndex("date_update")).trim();                    ПолученныйПубличныйID= Курсор_7ДнейЗаходаПользователя.getInt(Курсор_7ДнейЗаходаПользователя.getColumnIndex("id"));                    Log.d(this.getClass().getName(), "  success_users  " + success_users + "  " +                            "    success_login  " + success_login + " date_update " + date_update);                    // TODO: 13.08.2023 дата из табции                    Date ДатаSucceslogin =                            new android.icu.text.SimpleDateFormat("yyyy-MM-dd",                                    new Locale("ru")).parse(date_update);//TODO "2023-08-01 19:00:59.781"                    Log.d(this.getClass().getName(), "  ДатаSucceslogin  " + ДатаSucceslogin);                    // TODO: 13.08.2023 Дата NOW !!!!!                    Date ДатаNOW = Calendar.getInstance().getTime();                    DateFormat dateFormat = new java.text.SimpleDateFormat("yyyy-MM-dd", new Locale("ru"));//"yyyy-MM-dd'T'HH:mm:ss'Z'                    String ДатСегодняДатаNOW = dateFormat.format(ДатаNOW);                    ДатаNOW = dateFormat.parse(ДатСегодняДатаNOW);                    Log.d(this.getClass().getName(), "  ДатаNOW  " + ДатаNOW);                    ////TODO само сравнивание дат на 7 дней назад                    long РазницаМеждуДатамиNowИДатыИзБазы =                            ДатаNOW.getTime()                                    - ДатаSucceslogin.getTime(); //локальное сравнение дата из базы андройда и дат сегодня                    ///////////                    ФиналПолучаемРазницуМеждуДатами = Integer.parseInt("" + (TimeUnit.DAYS.convert(РазницаМеждуДатамиNowИДатыИзБазы, TimeUnit.MILLISECONDS)));                    Log.d(this.getClass().getName(), "  ФиналПолучаемРазницуМеждуДатами  " + ФиналПолучаемРазницуМеждуДатами);                }                // TODO: 13.08.2023                if (Курсор_7ДнейЗаходаПользователя != null) {                    Курсор_7ДнейЗаходаПользователя.close();///                }                Log.d(this.getClass().getName(), "  ФиналПолучаемРазницуМеждуДатами  " + ФиналПолучаемРазницуМеждуДатами);            } catch (Exception e) {                e.printStackTrace();                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                        " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }        ///////todo ФИНАЛЬНЫЙ МЕТОД КТО ВХОДИЛ ДО 7 ДНЕЙ ИЛИ ПОСЫЛАЕМ НА АУНТИФИКАЦИЮ       Boolean metodAsyncUpdatePO() {            Boolean ФлагЗапускаAsyncБезUpdatePO=false;            try {//////FLAG_ACTIVITY_SINGLE_TOP                ФлагЗапускаAsyncБезUpdatePO =                        localBinderОбновлениеПО.getService().МетодГлавныйОбновленияПОДоAsync(true, activity, handlerUpdatePO);                Log.i(this.getClass().getName(), " Атоманически установкаОбновление ПО " +                        Thread.currentThread().getStackTrace()[2].getMethodName() + " время " + new Date().toLocaleString());                Log.i(this.getClass().getName(), "R.id.item_async_updatepo  "                        + Thread.currentThread().getStackTrace()[2].getMethodName() + " время " + new Date().toLocaleString() +                        "ФлагЗапускаAsyncБезUpdatePO " + ФлагЗапускаAsyncБезUpdatePO);                Log.d(getApplicationContext().getClass().getName(), "\n"                        + " время: " + new Date() + "\n+" +                        " Класс в процессе... " + this.getClass().getName() + "\n" +                        " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName()                        + " localBinderОбновлениеПО.isBinderAlive() " + localBinderОбновлениеПО.isBinderAlive() +                        " date_update " + date_update + " success_users "+success_users + " success_login " +success_login  +                           " ФиналПолучаемРазницуМеждуДатами "+ФиналПолучаемРазницуМеждуДатами  +                        "  СтатусРаботыСервера "+СтатусРаботыСервера);                            } catch (Exception e) {                e.printStackTrace();                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                        " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(),                        Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());            }            return  ФлагЗапускаAsyncБезUpdatePO;        }        @SuppressLint("SuspiciousIndentation")        private void МетодПингаКСереруЗапущенЛиСерерИлиНет() {            try {                // TODO: 16.12.2021 НЕПОСРЕДСТВЕННЫЙ ПИНГ СИСТЕНМ ИНТРЕНАТ НА НАЛИЧЕНИ СВАЗИ С БАЗОЙ SQL SERVER                СтатусРаботыСервера =                        new Class_Connections_Server(getApplicationContext()).                                МетодПингаСервераРаботаетИлиНет(getApplicationContext());                Log.d(this.getClass().getName(), "  СтатусРаботыСервера " + СтатусРаботыСервера);            } catch (Exception e) {                e.printStackTrace();                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                        " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                        this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }        private void medodVisiblePrograssbar(@NonNull Boolean ФлагПрограсБАр) {            try {                if (СтатусРаботыСервера == true) {                    activity.runOnUiThread(new Runnable() {                        @Override                        public void run() {                            progressbarbootandasync.setIndeterminate(ФлагПрограсБАр);                            progressbarbootandasync.requestLayout();                            progressbarbootandasync.refreshDrawableState();                        }                    });                        }                Log.d(getApplicationContext().getClass().getName(), "\n"                        + " время: " + new Date() + "\n+" +                        " Класс в процессе... " + this.getClass().getName() + "\n" +                        " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName()                        + " localBinderОбновлениеПО.isBinderAlive() " + localBinderОбновлениеПО.isBinderAlive() +                        "  СтатусРаботыСервера " + СтатусРаботыСервера);            } catch (Exception e) {                e.printStackTrace();                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                        " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                        this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }        void metodExitBindingeService() {            try {//////FLAG_ACTIVITY_SINGLE_TOP                logicBinessMainActivity_from_face_start.   medodVisiblePrograssbar(false);                if (connectionОбновлениеПО!=null) {                    unbindService(connectionОбновлениеПО);                }                if (connectionAsync!=null) {                    unbindService(connectionAsync);                }                Log.d(getApplicationContext().getClass().getName(), "\n"                        + " время: " + new Date() + "\n+" +                        " Класс в процессе... " + this.getClass().getName() + "\n" +                        " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName());            } catch (Exception e) {                e.printStackTrace();                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                        " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(),                        Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }                void metoEndingAsynsDashboard() {                    try {                        Intent Интент_ЗапускаетBootAndAsync = new Intent();                        Интент_ЗапускаетBootAndAsync.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);                        Интент_ЗапускаетBootAndAsync.setAction("MainActivity_Dashboard.class");                                Интент_ЗапускаетBootAndAsync.setClass(getApplicationContext(), MainActivity_Dashboard.class);                                  Bundle bundleBinderUpdate=new Bundle();                        bundleBinderUpdate.putBinder("callbackbinderdashbord", localBinderОбновлениеПО);                                Интент_ЗапускаетBootAndAsync.putExtras(bundleBinderUpdate);                                startActivity(Интент_ЗапускаетBootAndAsync);//tso                                finishAfterTransition();                                Log.d(this.getClass().getName(), "  ФиналПолучаемРазницуМеждуДатами  " + ФиналПолучаемРазницуМеждуДатами                                        + " date_update " + date_update + " СтатусРаботыСервера " + СтатусРаботыСервера);                    } catch (Exception e) {                        e.printStackTrace();                        Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                                " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                        new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(),                                Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());                    }                }        void boundserviceexit() {            try {                if (connectionОбновлениеПО!=null) {                    unbindService(connectionОбновлениеПО);                }                if (connectionAsync!=null) {                    unbindService(connectionAsync);                }                Log.d(this.getClass().getName(), "  ФиналПолучаемРазницуМеждуДатами  " + ФиналПолучаемРазницуМеждуДатами                        + " date_update " + date_update + " СтатусРаботыСервера " + СтатусРаботыСервера);            } catch (Exception e) {                e.printStackTrace();                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                        " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(),                        Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }        void metoEndingAsynsSharedPreferences() {            try {                SharedPreferences.Editor editor = preferences.edit();                editor.putInt("PublicId", ПолученныйПубличныйID);                editor.apply();                Log.d(this.getClass().getName(), "  ФиналПолучаемРазницуМеждуДатами  " + ФиналПолучаемРазницуМеждуДатами                        + " date_update " + date_update + " СтатусРаботыСервера " + СтатусРаботыСервера);            } catch (Exception e) {                e.printStackTrace();                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                        " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(),                        Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }        void metoEndingAsynsRetryBroadCastResiver() {            try {                // TODO: 07.10.2023                ClassRegistraAsyncBroadcast classRegistraAsyncBroadcast =new ClassRegistraAsyncBroadcast();;               classRegistraAsyncBroadcast.metodSendBroadCastFroAsyns(getApplicationContext(),"KEEP");                Log.d(getApplicationContext().getClass().getName(), "\n"                        + " время: " + new Date()+"\n+" +                        " Класс в процессе... " +  this.getClass().getName()+"\n"+                        " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName());            } catch (Exception e) {                e.printStackTrace();                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                        " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(),                        Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }        private void МетодСообщениеПользоватлюЧтоНЕтИнтренета(String КакойРежимОтоброжать) {            activity.runOnUiThread(new Runnable() {                @Override                public void run() {                    Toast toast = Toast.makeText(getApplicationContext(), КакойРежимОтоброжать, Toast.LENGTH_LONG);                    toast.setGravity(Gravity.BOTTOM, 0, 40);                    toast.show();                }            });        }        @SuppressLint("Range")        Boolean getBlockCurrentUser() {            Boolean СтатусБлокировкиПользотеляТекущего = true;            try {                Uri uri = Uri.parse("content://com.dsy.dsu.providerdatabasecurrentoperations/" + "chat_users" + "");                ContentResolver contentResolver= getContentResolver();                Cursor  суксорЗаблокированыхПользотель =      contentResolver.query(uri,new String[]{},                        new String(" SELECT locked  FROM chat_users  WHERE _id= ?  ORDER BY date_update DESC "),                        new String[]{String.valueOf(ПолученныйПубличныйID)},null);///   "  //// SELECT * FROM  viewtabel WHERE year_tabels=?  AND month_tabels=?  AND cfo=?  AND status_send!=?                Log.d(this.getClass().getName(), "  суксорЗаблокированыхПользотель " +  суксорЗаблокированыхПользотель);                Log.d(this.getClass().getName(), "суксорЗаблокированыхПользотель " + суксорЗаблокированыхПользотель);                if (суксорЗаблокированыхПользотель.getCount() > 0) {                    суксорЗаблокированыхПользотель.moveToFirst();                  String СтатусБлокировки = суксорЗаблокированыхПользотель.getString(суксорЗаблокированыхПользотель.getColumnIndex("locked"));                    СтатусБлокировкиПользотеляТекущего = Boolean.parseBoolean(СтатусБлокировки.toString());                }                if (суксорЗаблокированыхПользотель != null) {                    суксорЗаблокированыхПользотель.close();                }                // TODO: 28.07.2022                Log.d(this.getClass().getName(), " СтатусБлокировкиПользотеляТекущего " + СтатусБлокировкиПользотеляТекущего);            } catch (Exception e) {                e.printStackTrace();                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                        this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }            return  СтатусБлокировкиПользотеляТекущего;        }        // TODO: 14.08.2023  END END LogicBinessMainActivity_From_Face_Start    }////TODO END LogicBinessMainActivity_From_Face_Start   END LogicBinessMainActivity_From_Face_Start   END LogicBinessMainActivity_From_Face_Start    // TODO: 02.10.2023  Клса Подписки Subcir    class ClassBindServicePublish {        public void metodBindServiceAsyncPublish() {            // TODO: 02.10.2023  init            try{                AsyncPublish = PublishSubject.create();                AsyncPublish.filter(fil->fil.isBinderAlive()) .publish();                UpdatePublish = PublishSubject.create();                UpdatePublish.filter(fil->fil.isBinderAlive()) .publish();                // TODO: 18.12.2023                Observable.combineLatest(AsyncPublish, UpdatePublish,                                new BiFunction<Service_For_Remote_Async_Binary.LocalBinderAsync, ServiceUpdatePoОбновлениеПО.localBinderОбновлениеПО, Object>() {                                    @Override                                    public Object apply(Service_For_Remote_Async_Binary.LocalBinderAsync localBinderAsync,                                                        ServiceUpdatePoОбновлениеПО.localBinderОбновлениеПО localBinderОбновлениеПО) throws Throwable {                                        Flowable.fromAction(new Action() {                                            @Override                                            public void run() throws Throwable {                                                // TODO: 14.08.2023 создаем папку для BinaryFile Save                                                new ClassCreateFolderBinatyMatrilal(getApplicationContext()).МетодCreateFoldersBinaty();                                                // TODO: 14.08.2023 создаем папку для BinaryFile CommitPay1C Соласования                                                new ClassCreateFolderCommitPays1C(getApplicationContext()).МетодCreateFoldersBinaty();                                                // TODO: 14.08.2023  Запускаем Код До Сиинхрониазщции                                                logicBinessMainActivity_from_face_start.МетодОпределениеКогдаПоследнийРазЗаходилПользователь();                                                logicBinessMainActivity_from_face_start.   МетодПингаКСереруЗапущенЛиСерерИлиНет();                                                logicBinessMainActivity_from_face_start.   medodVisiblePrograssbar(true);                                                Log.d(this.getClass().getName(), "\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                                                        " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                                                        " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n" +                                                        " localBinderAsync "+localBinderAsync.isBinderAlive()+ " " +                                                        " localBinderОбновлениеПО "  + localBinderОбновлениеПО.isBinderAlive() );                                                // TODO: 03.10.2023 ЕСЛИ ЕСТЬ ПАРОЛЬ И ЛОГИН ПО ЗАХОД ЕСЛИ НЕТ ТО ПАОЛДЬБ                                                if (      date_update != null && success_users != null && success_login != null                                                        && ФиналПолучаемРазницуМеждуДатами < 20  ) {                                                    new SuccessAsynsStartingUpdatrPO().startingAsyncForUpSoft();                                                    Log.d(getApplicationContext().getClass().getName(), "\n"                                                            + " время: " + new Date() + "\n+" +                                                            " Класс в процессе... " + this.getClass().getName() + "\n" +                                                            " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName()                                                            + " localBinderОбновлениеПО.isBinderAlive() " + localBinderОбновлениеПО.isBinderAlive());                                                }else {                                                    // TODO: 28.04.2023 НЕт Анутифтикации Пароль                                                    new ClassNotPassword(). методПереходНаActivityPassword(СтатусРаботыСервера );                                                    Log.d(this.getClass().getName(), "  ФиналПолучаемРазницуМеждуДатами  " + ФиналПолучаемРазницуМеждуДатами                                                            + " date_update " + date_update + " СтатусРаботыСервера " + СтатусРаботыСервера);                                                }                                                Log.d(getApplicationContext().getClass().getName(), "\n"                                                        + " время: " + new Date() + "\n+" +                                                        " Класс в процессе... " + this.getClass().getName() + "\n" +                                                        " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName()                                                        + " ФиналПолучаемРазницуМеждуДатами " + ФиналПолучаемРазницуМеждуДатами);                                            }                                        }).subscribeOn(Schedulers.single())                                                .observeOn(AndroidSchedulers.mainThread())                                                .doOnError(new Consumer<Throwable>() {                                                    @Override                                                    public void accept(Throwable throwable) throws Throwable {                                                        throwable.printStackTrace();                                                        Log.e(this.getClass().getName(), "Ошибка " + throwable + " Метод :"                                                                + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                                                + Thread.currentThread().getStackTrace()[2].getLineNumber());                                                        new Class_Generation_Errors(getApplicationContext())                                                                .МетодЗаписиВЖурналНовойОшибки(throwable.toString(), this.getClass().getName(),                                                                        Thread.currentThread().getStackTrace()[2].getMethodName(),                                                                        Thread.currentThread().getStackTrace()[2].getLineNumber());                                                    }                                                })                                                .doOnComplete(new Action() {                                            @Override                                            public void run() throws Throwable {                                                                                             Log.d(getApplicationContext().getClass().getName(), "\n"                                                        + " время: " + new Date() + "\n+" +                                                        " Класс в процессе... " + this.getClass().getName() + "\n" +                                                        " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName()                                                        + " ФиналПолучаемРазницуМеждуДатами " + ФиналПолучаемРазницуМеждуДатами);                                            }                                        }).subscribe();                                        return localBinderAsync;                                    }                                })                        .doOnError(new Consumer<Throwable>() {                            @Override                            public void accept(Throwable throwable) throws Throwable {                                throwable.printStackTrace();                                Log.e(this.getClass().getName(), "Ошибка " + throwable + " Метод :"                                        + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                                new Class_Generation_Errors(getApplicationContext())                                        .МетодЗаписиВЖурналНовойОшибки(throwable.toString(), this.getClass().getName(),                                                Thread.currentThread().getStackTrace()[2].getMethodName(),                                                Thread.currentThread().getStackTrace()[2].getLineNumber());                            }                        }).filter(fil->fil!=null).subscribe();            Log.d(this.getClass().getName(), "\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n" +                    " localBinderAsync ");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :"                    + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }        }//TODO succeess        class SuccessAsynsStartingUpdatrPO{            void startingAsyncForUpSoft(){                try{                    // TODO: 03.10.2023 запуск Анализ По                    if (      СтатусРаботыСервера == true  ) {                    // TODO: 03.10.2023                    Boolean    ФлагЗапускаAsyncБезUpdatePO=        logicBinessMainActivity_from_face_start.metodAsyncUpdatePO();                        // TODO: 03.10.2023  запускаем синхрониазцию                        Long ФинальныйРезультатAsyncBackgroud = null;                        if (ФлагЗапускаAsyncБезUpdatePO==true) {                            // TODO: 03.10.2023 Запуск Синхронизации                            ФинальныйРезультатAsyncBackgroud = localBinderAsync.getService().metodStartingSync(  handlerAsync,getApplicationContext());                            // TODO: 27.10.2022  МетодАнализа Заблокирован или Нет пользователь и запуск Программы                            Boolean СтатусБлокировкиПользотеляТекущего=   logicBinessMainActivity_from_face_start.getBlockCurrentUser();                            if (СтатусБлокировкиПользотеляТекущего==false) {                                // TODO: 03.10.2023 КОНЕЦ                                logicBinessMainActivity_from_face_start.   metoEndingAsynsSharedPreferences();                                logicBinessMainActivity_from_face_start.  metoEndingAsynsRetryBroadCastResiver();                                logicBinessMainActivity_from_face_start. boundserviceexit();                                logicBinessMainActivity_from_face_start.metoEndingAsynsDashboard();                            } else {                                logicBinessMainActivity_from_face_start.     МетодСообщениеПользоватлюЧтоНЕтИнтренета("Режим: (пользователь заблок.)");                                // TODO: 28.04.2023 НЕт Анутифтикации Пароль                                new ClassNotPassword(). методПереходНаActivityPassword(СтатусРаботыСервера );                            }                            // TODO: 03.10.2023                            Log.d(this.getClass().getName(), "\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n" +                                    " ФинальныйРезультатAsyncBackgroud  Запуск Синхронизации "+ФинальныйРезультатAsyncBackgroud);                        }                    }else {                        logicBinessMainActivity_from_face_start.     МетодСообщениеПользоватлюЧтоНЕтИнтренета("Режим: (офлайн)");                        // TODO: 03.10.2023 КОНЕЦ                        logicBinessMainActivity_from_face_start.   metoEndingAsynsSharedPreferences();                        logicBinessMainActivity_from_face_start.  metoEndingAsynsRetryBroadCastResiver();                        logicBinessMainActivity_from_face_start. boundserviceexit();                        logicBinessMainActivity_from_face_start.metoEndingAsynsDashboard();                    }                    Log.d(this.getClass().getName(), "\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                            " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                            " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n" +                            " localBinderAsync ");                } catch (Exception e) {                    e.printStackTrace();                    Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :"                            + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                            + Thread.currentThread().getStackTrace()[2].getLineNumber());                    new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                            this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                            Thread.currentThread().getStackTrace()[2].getLineNumber());                }            }        }//TODO  end SuccessAsynsStartingUpdatrPO        // TODO: 18.12.2023 dont password        // TODO: 03.10.2023 Класс РАботает когда есть успиешный ПИНГ        // TODO: 03.10.2023 Class NOT PASSWORDS        class ClassNotPassword{            private void методПереходНаActivityPassword(@NonNull boolean СтатусРаботыСервера ) {                try {                    Intent   Интент_ЗапускаетFaceApp=new Intent();                    Интент_ЗапускаетFaceApp.setClass(getApplicationContext(), MainActivityPasswords.class);                    Интент_ЗапускаетFaceApp.setAction("MainActivityPasswords.class");                    startActivity(Интент_ЗапускаетFaceApp);//tso                    finishAfterTransition();                    Log.d(this.getClass().getName(), "  ФиналПолучаемРазницуМеждуДатами  " + ФиналПолучаемРазницуМеждуДатами                            + " date_update " + date_update + " СтатусРаботыСервера " + СтатусРаботыСервера);                } catch (Exception e) {                    e.printStackTrace();                    Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                            " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                    new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(),                            Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());                }            }        }        private void МетодБоковаяПанельОткрытьЗАкрыть() {            try {                if (drawerLayoutAsync.isDrawerOpen(Gravity.LEFT)) {                    drawerLayoutAsync.closeDrawer(Gravity.LEFT);                }            } catch (Exception e) {                e.printStackTrace();                ///метод запись ошибок в таблицу                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                        Thread.currentThread().getStackTrace()[2].getLineNumber());            }        }        // TODO: 03.04.2022    }    // TODO: 25.10.2023 test code start             class MainTest extends AllTestsBusinessLogic {        //todo #1        class TEstHttpSimpleConnection extends  TestServer{            public TEstHttpSimpleConnection() {                super( getApplicationContext());            }            @Override            public void metodTest() {                Completable.fromAction(new Action() {                                           @Override                                           public void run() throws Throwable {                                               connection = (HttpURLConnection) (urltest).openConnection();/////САМ ФАЙЛ JSON C ДАННЫМИ                                               connection.setRequestProperty("Content-Type", "application/txt ;charset=UTF-8");                                               connection.setRequestProperty("Accept-Encoding", "gzip,deflate,sdch");                                               connection.setRequestProperty("Connection", "Keep-Alive");                                               connection.setRequestProperty("Accept-Language", "ru-RU");                                               connection.setRequestMethod("GET"); ///   HEAD GET //ПРОВЕРЯЕМ ЕСЛИ ПОДКЛЮЧЕНИЕ К СЕВРЛЕТУ НА СЕРВЕР ВЫБРАСЫВАЕМ                                               connection.setReadTimeout(10000); //todo САМ ТАЙМАУТ ПОДКЛЮЧЕНИЕ(30000);                                               connection.setConnectTimeout(10000);//todo САМ ПОТОК ДАННЫХ(1000); САМ STREAM                                               connection.setUseCaches(true);                                               connection.connect(); /////////////ТОЛЬКО СОЕДИНЕНИЕ                                               connection.getContent(); ////РЕАЛЬНОЕ ПОЛУЧЕНИЕ ДАННЫХ С ИНТРЕНЕТА                                               // TODO: 11.08.2021 получениея версии чата версия данных CURRENT _CHAT                                               Log.d(this.getClass().getName(), "ПодключениеПолученияДанныхсСервер.getHeaderField(current_chat_server) " + connection.getHeaderField("stream_current_chat_server"));                                               // TODO: 11.08.2021 ВекрсияДанных с сервера на Сервера                                               Long РезультатВерсииДанныхЧатаНаСервере=0l;                                               РезультатВерсииДанныхЧатаНаСервере= Long.parseLong(connection.getHeaderField("stream_current_chat_server"));                                               Log.d(this.getClass().getName(), "РезультатВерсииДанныхЧатаНаСервере " + РезультатВерсииДанныхЧатаНаСервере);                                               ////TODO И ЕСЛИ ПРИШЕЛ ОТ СЕРВЕРА ОТВЕТ ПОЛОЖИТЕЛЬНО ТО ТОГДА ЗАПУСКАМ ПРОЧТЕНИЯ ПОТОКА ПРИШЕДШЕГО С СЕРВЕРА                                               if (connection.getResponseCode() == 200 && РезультатВерсииДанныхЧатаНаСервере > 0) {                                                   //TODO шифровани                                                   Log.i(this.getClass().getName(), "ПОТОК ПРИШЕЛ НУЛОВОЙ ОТ СЕРВЕРА  " + connection.getInputStream().available());                                               }    else {                                                   Log.i(this.getClass().getName(), "ПОТОК ПРИШЕЛ НУЛОВОЙ ОТ СЕРВЕРА  " + connection.getInputStream().available());                                               }                                               connection.disconnect();                                               Log.d(this.getClass().getName(), "\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                                                       " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                                                       " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n");                                           }                                       }                        )                        .subscribeOn(Schedulers.single())                        .blockingSubscribe(new CompletableObserver() {                            @Override                            public void onSubscribe(@io.reactivex.rxjava3.annotations.NonNull Disposable d) {                                Log.d(this.getClass().getName(), "\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                                        " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                                        " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n" );                            }                            @Override                            public void onComplete() {                                Log.d(this.getClass().getName(), "\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                                        " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                                        " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n" );                            }                            @Override                            public void onError(@io.reactivex.rxjava3.annotations.NonNull Throwable e) {                                Log.d(this.getClass().getName(), "\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                                        " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                                        " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n" );                            }                        });                // super.metodTest();                Log.d(this.getClass().getName(), "\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                        " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                        " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n" );            }        }}  // TODO: 25.10.2023  end MainTest}